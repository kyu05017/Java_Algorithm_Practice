[1일차]

    [1-1강]

        1. 프로그램이 하는일은? (정보처리) -> 정보를 처리한다는 뜻
            1-2. 정보(자료구조) : 구조화된 데이터
            1-3. 처리(알고리즘) : 논리적으로 절차를 걸처 업부를 수행한다.
            1-4. 프로그램 : 자료구조 + 알고리즘
            1-5. 프로그램을 만드는 중요한 요소는 언어가 아닌 자료구조와 알고리즘이다.

        2. 자료 - 구조화된 데이터
            2-1. 변수
            2-2. 배열     (선영자료구조)
            2-3. 리스트   (선영자료구조)
            2-4. 맵       (비선영자료구조)
            2-5. 그래프   (비선영자료구조)
            2-6. 트리     (비선영자료구조)

    [1-2강] JAVA 언어는 데이터를 어떻게 표현하는가?

        1. 데이터 타입
            1. Primitive (원시타입) - 자바는 JVM(가상머신)을 사용하기에 항상 같은 타입 사용가능
                1-1.byte    1byte       -2^7    ~ 2^7 -1
                1-2.short   2byte       -2^15   ~ 2^15 -1
                1-3.int     4byte       -2^31   ~ 2^31 -1
                1-4.long    8byte       -2^63   ~ 2^63 -1
                1-5.float   4byte       -1.111 x 2^127 ~ 1.111 x 2^127
                1-6.double  8byte       -1.111 x 2^1023 ~ 1.111 x 2^1023
                1-7char     2byte       0 ~ 2^16 -1
                1-8.boolean notDefined

            2. Reference (객체타입)
                2-1.Object 객체에 상속되어 있는 클래스 그외 ...
                2-2.ex) Long, Integer, Double, String

            3. 데이터 적제 방식
                1. Primitive 타입
                    1-1. 할당된 변수의 메모리위치에 값을 저장함

                2. Reference 타입
                    2-1. 할당된 변수의 메모리위치에 값의 주소값(레퍼런스 주소)을 저장해 찾아사용

                    2-2. String 객체의 특징 문자열에 ( += "S" ) 와 같이 문자열이 추가되면 실제 저장된 메모리에 적층하는게 아니라
                        새로운 메모리 위치에 문자열을 저장됨 자바에서는 String Immutable(불변성) 객체라 표현함

    [1-3강] 시간복잡도
        1. 좋은 프로그램이란 무엇인가?
            1-1. 서비스 관점    : 원하는 동작 수행, 오류없고, 가격이 싸고 디자인이 이쁘고...등등
            1-2. 알고리즘 관점  :
                1. 신뢰성이 높은 알고리즘
                2. 처리 효율이 높은 알고리즘 ( 시간 복잡도 Big O 표기법 { O(n) } )
                    2-1. 어떠한 알고리즘에 데이터가 n개 들어갔을 때, n개에 대비해서 얼마나 많은량의 연산을 수행하느냐는 것에 대한 변화를 표현한는 방법
                3. 일반적으로 적용이 가능한 알고리즘
                4. 확장성이 있는 알고리즘
                5. 이해하기 쉬운 알고리즘
                6. 이식성이 높은 알고리즘

        2. 시간복잡도

            1. Ex) O(1)
                int func1(int[] n){
                    if(n.length < 3){
                        return 0;
                    }

                    int a = n[0];
                    a += n[1];
                    a += n[2];

                    return a;
                }

                연산의 량이 변함이 없이 일정하다.

            2. Ex) O(n)
                int sum(int[] n){
                    int s = 0l

                    for(int i : n){
                        s += i;
                    }

                    return s;
                }
                n 정수 배열이 증가할수록 시간복잡도가 증가한다.

            3. Ex) O(n^2)
                void bubbleSort(int[] n){
                    for(int i = 0; i < n.length; i++){
                        for(int j = 0; j < n.length; j++){\
                            if(n[i] < [j]){
                                int tmp = n[j];
                                n[j] = n[i];
                                n[i] = temp;
                            }
                        }
                    }
                }
                n이 증가 하면 제곱으로 시간복잡도가 증가한다.

            4. Ex) O(logN)
                int sum(int[] n){
                    int sum = 0;
                    int max = n.length;

                    while(max > 0){
                        sum += n[max - 1];
                        max /= 2;
                    }
                }
                루프를 돌면 돌수록 n개가 들어와도 수행하는 횟수가 절반씩 줄어든다.

        3. 정리
            1. 시간복잡도는 수학적으로 정확한 계산이 아닌 n이 얼마나 증가하느냐를 비교하는 척도
